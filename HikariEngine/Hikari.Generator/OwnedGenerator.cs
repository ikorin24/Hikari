#nullable enable
using Microsoft.CodeAnalysis;
using System.Linq;
using System.Text;

namespace Hikari.Generator;

[Generator(LanguageNames.CSharp)]
internal class OwnedGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("OwnedAttribute.g.cs", """
// <auto-generated>

#nullable enable

namespace Hikari;

[global::System.AttributeUsage(global::System.AttributeTargets.Constructor, AllowMultiple = false, Inherited = false)]
[global::System.Diagnostics.Conditional("COMPILE_TIME_ONLY")]
internal sealed class OwnedAttribute : global::System.Attribute
{
    public OwnedAttribute(string releaseMethod)
    {
    }

    public OwnedAttribute(string createMethodName, string releaseMethod)
    {
    }
}

""");
        });

        var attrAttached = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Hikari.OwnedAttribute",
            static (_, ct) => true,
            static (context, ct) => context);

        context.RegisterSourceOutput(
            context.SyntaxProvider.ForAttributeWithMetadataName(
                "Hikari.OwnedAttribute",
                static (_, ct) => true,
                static (context, ct) => context).Collect(),
            static (context, array) =>
        {
            foreach(var group in array.GroupBy(a => a.TargetSymbol.ContainingType, SymbolEqualityComparer.Default)) {
                if(group.Key is not INamedTypeSymbol type) {
                    continue;
                }
                var code = new StringBuilder();
                code.AppendLine($$"""
// <auto-generated>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604
""");
                foreach(var attrAttached in group) {
                    var ctor = (IMethodSymbol)attrAttached.TargetSymbol;
                    var parameters = string.Join(", ", ctor.Parameters.Select(p => p.ToDisplayString()));
                    var args = string.Join(", ", ctor.Parameters.Select(p =>
                    {
                        var refKind = p.RefKind switch
                        {
                            RefKind.Ref => "ref",
                            RefKind.Out => "out",
                            RefKind.In => "in",
                            _ => p.ToDisplayString().StartsWith("ref readonly ") switch
                            {
                                true => "in",
                                false => "",
                            },
                        };
                        return $"{refKind} {p.Name}";
                    }));
                    var attrArgs = attrAttached.Attributes[0].ConstructorArguments;
                    var (createMethodName, releaseMethod) = attrArgs switch
                    {
                        { Length: 1 } => ("Create", attrArgs[0].Value as string ?? ""),
                        { Length: 2 } => (attrArgs[0].Value as string ?? "", attrArgs[1].Value as string ?? ""),
                        _ => ("", ""),
                    };
                    if(type.IsValueType) {
                        throw new System.NotImplementedException();
                    }
                    var (beginSource, endSource, kind, typeName) = GetContainingSource(type);
                    code.AppendLine($$"""
{{beginSource}}

partial {{kind}} {{typeName}}
{
    public static global::Hikari.Own<{{typeName}}> {{createMethodName}}({{parameters}})
    {
        var self = new {{typeName}}({{args}});
        return global::Hikari.Own.New(self, static obj =>
        {
            var self = global::System.Runtime.CompilerServices.Unsafe.As<{{typeName}}>(obj);
            self.{{releaseMethod}}();
        });
    }
}

{{endSource}}
""");
                }

                var filename = type
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                    .Replace("global::", "")
                    .Replace("<", "_")
                    .Replace(">", "_")
                    + ".g.cs";
                context.AddSource(filename, code.ToString());
            }
        });
    }


    private static (string BeginSource, string EndSource, string Kind, string TypeName) GetContainingSource(INamedTypeSymbol typeSymbol)
    {
        var current = typeSymbol;
        var begin = new StringBuilder();
        var end = new StringBuilder();
        var kind = (typeSymbol.TypeKind, typeSymbol.IsRecord) switch
        {
            (TypeKind.Class, true) => "record",
            (TypeKind.Class, false) => "class",
            (TypeKind.Struct, true) => "record struct",
            (TypeKind.Struct, false) => "struct",
            (TypeKind.Interface, _) => "interface",
            (TypeKind.Enum, _) => "enum",
            _ => "_",
        };
        var typeName = typeSymbol.Name;
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {typeSymbol.ContainingNamespace}\n{{";
        begin.AppendLine(ns);

        while(true) {
            if(current.ContainingType is INamedTypeSymbol containingTypeSymbol == false) {
                break;
            }
            var typeKind = (containingTypeSymbol.TypeKind, containingTypeSymbol.IsRecord) switch
            {
                (TypeKind.Class, true) => "record",
                (TypeKind.Class, false) => "class",
                (TypeKind.Struct, true) => "record struct",
                (TypeKind.Struct, false) => "struct",
                (TypeKind.Interface, _) => "interface",
                (TypeKind.Enum, _) => "enum",
                _ => "_",
            };
            begin.AppendLine($$"""
partial {{typeKind}} {{containingTypeSymbol.Name}}
{
""");
            end.AppendLine("}");
            current = containingTypeSymbol;
        }
        if(ns != "") {
            end.AppendLine("}");
        }
        return (begin.ToString(), end.ToString(), kind, typeName);
    }
}
