#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System;
using System.Collections.Immutable;

namespace EnumMapper;

[Generator]
public sealed class SequentialSetGenerator : IIncrementalGenerator
{
    private const string SequentialSetAttributeSource = """
// <auto-generated>
#nullable enable
namespace EnumMapping;

[global::System.Diagnostics.Conditional("COMPILE_TIME_ONLY")]
[global::System.AttributeUsage(global::System.AttributeTargets.Enum, AllowMultiple = false, Inherited = false)]
internal sealed class SequentialSetAttribute : global::System.Attribute
{
    public SequentialSetAttribute() { }
    public SequentialSetAttribute(string constFieldName) { }
}

""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("SequentialSetAttribute.g.cs", SourceText.From(SequentialSetAttributeSource, Encoding.UTF8));
        });

        var seqSetAttrSymbol = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("EnumMapping.SequentialSetAttribute") ?? throw new Exception("SequentialSetAttribute is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        var dataArray = context
            .SyntaxProvider
            .CreateSyntaxProvider(
            static (node, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return node is EnumDeclarationSyntax;
            },
            static (context, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var semantics = context.SemanticModel;
                var enumSymbol = semantics.GetDeclaredSymbol((context.Node as EnumDeclarationSyntax)!, ct);
                return (enumSymbol, semantics);
            })
            .Combine(seqSetAttrSymbol)
            .Select(static (x, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var ((enumSymbol, semantics), seqSetAttrSymbol) = x;
                if(enumSymbol is null) { return default; }
                var seqSetAttr = enumSymbol
                    .GetAttributes()
                    .FirstOrDefault(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, seqSetAttrSymbol));
                if(seqSetAttr is null) { return default; }
                var ctorArgs = seqSetAttr.ConstructorArguments;
                var fullname = enumSymbol.ToString();
                var constFieldName = (ctorArgs.Length >= 1) ? ctorArgs[0].Value?.ToString() ?? "" : enumSymbol.Name;

                if(ValidateSequential(enumSymbol, out var count) == false) {
                    return default;
                }
                return new Data(fullname, constFieldName, count);
            })
            .Where(static x => x != null)
            .Select((x, _) => x!)
            .WithComparer(EqualityComparer<Data>.Default)
            .Collect();

        context.RegisterSourceOutput(dataArray, static (context, dataArray) =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var source = CreateSource(dataArray);
            var sourceText = SourceText.From(source, Encoding.UTF8);
            context.AddSource("SequentialSet.g.cs", sourceText);
        });
    }

    private static bool ValidateSequential(INamedTypeSymbol enumSymbol, out int count)
    {
        var values = new List<int>();
        foreach(var enumField in enumSymbol.GetMembers().OfType<IFieldSymbol>()) {
            if(long.TryParse(enumField.ConstantValue?.ToString(), out long value) == false) {
                count = 0;
                return false;
            }
            if(value < 0) {
                count = 0;
                return false;
            }
            if(value > int.MaxValue) {
                count = 0;
                return false;
            }
            values.Add((int)value);
        }
        values.Sort();
        for(int i = 0; i < values.Count; i++) {
            if(values[i] != i) {
                count = 0;
                return false;
            }
        }

        count = values.Count;
        return true;
    }

    private static string CreateSource(ImmutableArray<Data> dataArray)
    {
        var sb = new StringBuilder();

        sb.AppendLine("""
// <auto-generated>
#nullable enable
namespace EnumMapping;

internal static class SequentialSet<T> where T : unmanaged, global::System.Enum
{
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static int Count()
    {
        if(TryGetCount(out var count) == false) {
            ThrowInvalidEnumType();
        }
        return count;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static bool TryGetCount(out int count)
    {
""");
        foreach(var data in dataArray) {
            sb.AppendLine($$"""
        if(typeof(T) == typeof(global::{{data.FullName}})) {
            count = global::EnumMapping.SequentialSetCount.{{data.ConstFieldName}};
            return true;
        }
""");
        }

        sb.AppendLine("""
        count = 0;
        return false;
    }

    [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
    private static void ThrowInvalidEnumType() => throw new global::System.InvalidOperationException($"'{typeof(T).FullName}' is invalid type for this operation.");
}
""");

        sb.AppendLine("""
internal sealed class SequentialSetCount
{
""");
        foreach(var data in dataArray) {
            sb.AppendLine($$"""
    public const int {{data.ConstFieldName}} = {{data.Count}};
""");
        }
        sb.AppendLine("""
}
""");

        return sb.ToString();
    }

    private record Data(string FullName, string ConstFieldName, int Count);
}
