#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System;
using System.Collections.Immutable;

namespace EnumMapper;

[Generator]
public sealed class EnumMapperGenerator : IIncrementalGenerator
{
    private const string EnumMapToAttributeSource = """
// <auto-generated>
#nullable enable

namespace EnumMapping;

[global::System.Diagnostics.Conditional("COMPILE_TIME_ONLY")]
[global::System.AttributeUsage(global::System.AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
internal sealed class EnumMapToAttribute : global::System.Attribute
{
    public EnumMapToAttribute(object value) { }
}
""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("EnumMapToAttribute.g.cs", SourceText.From(EnumMapToAttributeSource, Encoding.UTF8));
        });

        var enumMapToAttrSymbol = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("EnumMapping.EnumMapToAttribute") ?? throw new Exception("EnumMapToAttribute is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        var data = context
            .SyntaxProvider
            .CreateSyntaxProvider(
            static (node, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return node is EnumDeclarationSyntax;
            },
            static (context, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var semantics = context.SemanticModel;
                var enumSymbol = semantics.GetDeclaredSymbol((context.Node as EnumDeclarationSyntax)!, ct);
                return (enumSymbol, semantics);
            })
            .Combine(enumMapToAttrSymbol)
            .Select((x, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var ((enumSymbol, semantics), enumMapToAttrSymbol) = x;
                if(enumSymbol is null) { return default; }

                var comparer = SymbolEqualityComparer.Default;
                MapDefList? mapDefList = null;
                List<Diagnostic>? diagnostics = null;

                var enumTypeName = enumSymbol.ToString();
                foreach(var enumField in enumSymbol.GetMembers().OfType<IFieldSymbol>()) {
                    ct.ThrowIfCancellationRequested();
                    var enumMapToAttr = enumField
                        .GetAttributes()
                        .FirstOrDefault(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, enumMapToAttrSymbol));
                    if(enumMapToAttr is null) { continue; }
                    var arg0 = enumMapToAttr.ConstructorArguments[0];
                    if(arg0.Kind != TypedConstantKind.Enum) {
                        var location = enumMapToAttr.ApplicationSyntaxReference?.GetSyntax(ct)?.GetLocation() ?? Location.None;
                        var diag = DiagnosticHelper.InvalidTypeOfMappedValue(location, arg0.Value?.ToString());
                        (diagnostics ??= new()).Add(diag);
                        continue;
                    }
                    var mappedType = arg0.Type!.ToString();
                    var toValue = arg0.Value!.ToString();
                    (mapDefList ??= new(enumTypeName)).Add(mappedType, enumField.Name, toValue);
                }
                if(mapDefList != null) {
                    SelectedData? ret = new SelectedData(mapDefList.Value, diagnostics?.ToImmutableArray() ?? ImmutableArray<Diagnostic>.Empty);
                    return ret;
                }
                else {
                    return null;
                }
            })
            .Where(static x => x != null)
            .Select(static (x, _) => (SelectedData)x!)
            .WithComparer(SelectedData.ComparerOnSelected)
            .Collect();

        context.RegisterSourceOutput(data, static (context, data) =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            foreach(var diag in data.SelectMany(x => x.Diagnostics)) {
                context.ReportDiagnostic(diag);
            }
            var source = DumpSource(data.Select(x => x.Value).ToArray());
            var sourceText = SourceText.From(source, Encoding.UTF8);
            context.AddSource("EnumMapper.g.cs", sourceText);
        });
    }

    private static string DumpSource(MapDefList[] data)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
// <auto-generated>
#nullable enable

namespace EnumMapping;

internal static partial class EnumMapper
{
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static bool TryMapTo<TFrom, TTo>(this TFrom source, out TTo to)
        where TFrom : unmanaged, global::System.Enum
        where TTo : unmanaged, global::System.Enum
    {
        global::System.Runtime.CompilerServices.Unsafe.SkipInit(out to);
""");

        foreach(var defList in data) {
            var tFrom = defList.Type;
            foreach(var def in defList.Defs) {
                var tTo = def.MappedType;
                sb.AppendLine($$"""
        if(typeof(TFrom) == typeof(global::{{tFrom}}) && typeof(TTo) == typeof(global::{{tTo}})) {
            return TryMapPrivate(
                global::System.Runtime.CompilerServices.Unsafe.As<TFrom, global::{{tFrom}}>(ref source),
                out global::System.Runtime.CompilerServices.Unsafe.As<TTo, global::{{tTo}}>(ref to));
        }
""");
            }
        }

        sb.AppendLine("""
        to = default;
        return false;
    }
}

partial class EnumMapper
{
""");
        foreach(var defList in data) {
            var tFrom = defList.Type;
            foreach(var def in defList.Defs) {
                var tTo = def.MappedType;
                sb.AppendLine($$"""
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static bool TryMapPrivate(global::{{tFrom}} source, out global::{{tTo}} to)
    {
        switch(source) {
""");
                foreach(var (vFrom, vTo) in def.Values) {
                    sb.AppendLine($$"""
            case global::{{tFrom}}.{{vFrom}}: { to = ((global::{{tTo}}){{vTo}}); return true; }
""");
                }
                sb.AppendLine($$"""
            default: { to = default; return false; }
        }
    }
""");
            }
        }

        sb.AppendLine("""
}
""");

        sb.AppendLine("""
partial class EnumMapper
{
    [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
    private static void ThrowCannotMap<TFrom, TTo>(TFrom source)
    {
        throw new global::System.InvalidOperationException($"failed to map {source} of {typeof(TFrom).FullName} to {typeof(TFrom).FullName}");
    }
}
""");

        foreach(var defList in data) {
            var tFrom = defList.Type;
            if(defList.ContainsOnlySingleMappedType(out var tTo)) {

                // If defList contains only single mapped type,
                // strong typed methods are provided.

                sb.AppendLine($$"""
partial class EnumMapper
{
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static global::{{tTo}} MapOrDefault(this global::{{tFrom}} self)
    {
        return self.TryMapTo(out global::{{tTo}} value) ? value : default;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static global::{{tTo}} MapOr(this global::{{tFrom}} self, global::{{tTo}} defaultValue)
    {
        return self.TryMapTo(out global::{{tTo}} value) ? value : defaultValue;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static global::{{tTo}} MapOrThrow(this global::{{tFrom}} self)
    {
        if(self.TryMapTo(out global::{{tTo}} value) == false) {
            ThrowCannotMap<global::{{tFrom}}, {{tTo}}>(self);
        }
        return value;
    }
}
""");
            }
            else {
                sb.AppendLine($$"""
partial class EnumMapper
{
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static TTo MapOrDefault<TTo>(this global::{{tFrom}} self) where TTo : unmanaged, global::System.Enum
    {
        return self.TryMapTo(out TTo value) ? value : default;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static TTo MapOr<TTo>(this global::{{tFrom}} self, TTo defaultValue) where TTo : unmanaged, global::System.Enum
    {
        return self.TryMapTo(out TTo value) ? value : defaultValue;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static TTo MapOrThrow<TTo>(this global::{{tFrom}} self) where TTo : unmanaged, global::System.Enum
    {
        if(self.TryMapTo(out TTo value) == false) {
            ThrowCannotMap<global::{{tFrom}}, TTo>(self);
        }
        return value;
    }
}
""");
            }
        }
        return sb.ToString();
    }

    private readonly struct SelectedData
    {
        public static IEqualityComparer<SelectedData> ComparerOnSelected { get; } = new Comparer();

        public MapDefList Value { get; }
        public ImmutableArray<Diagnostic> Diagnostics { get; }

        public SelectedData(MapDefList value, ImmutableArray<Diagnostic> diagnostics)
        {
            Value = value;
            Diagnostics = diagnostics;
        }

        private sealed class Comparer : IEqualityComparer<SelectedData>
        {
            // Compare `Value` only. Ignore `Diagnostics`.

            public bool Equals(SelectedData x, SelectedData y) => x.Value.Equals(y.Value);

            public int GetHashCode(SelectedData obj) => obj.Value.GetHashCode();
        }
    }

    private readonly struct MapDefList : IEquatable<MapDefList>
    {
        public string Type { get; }
        public List<MapDef> Defs { get; } = new List<MapDef>();

        public static EqualityComparer<MapDefList> DefaultComparer = EqualityComparer<MapDefList>.Default;

        public MapDefList(string type)
        {
            Type = type;
        }

        public bool ContainsOnlySingleMappedType(out string mappedType)
        {
            if(Defs.Count == 0) {
                mappedType = null!;
                return false;
            }
            var t = Defs[0].MappedType;
            for(int i = 1; i < Defs.Count; i++) {
                if(Defs[i].MappedType != t) {
                    mappedType = null!;
                    return false;
                }
            }
            mappedType = t;
            return true;
        }

        public void Add(string mappedType, string fromValue, string toValue)
        {
            foreach(var def in Defs) {
                if(def.MappedType == mappedType) {
                    def.Values.Add((fromValue, toValue));
                    return;
                }
            }
            Defs.Add(new MapDef(mappedType, new() { (fromValue, toValue) }));
        }

        public override bool Equals(object? obj) => obj is MapDefList list && Equals(list);

        public bool Equals(MapDefList other)
        {
            // Deep equal
            return Type == other.Type && Defs.SequenceEqual(other.Defs);
        }

        public override int GetHashCode()
        {
            // Deep hash
            int hashCode = -1947855614;
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(Type);
            foreach(var item in Defs) {
                hashCode = hashCode * -1521134295 + EqualityComparer<MapDef>.Default.GetHashCode(item);
            }
            return hashCode;
        }
    }

    private readonly struct MapDef : IEquatable<MapDef>
    {
        public string MappedType { get; }
        public List<(string ValueFrom, string ValueTo)> Values { get; }

        private static readonly IEnumerable<(string From, string To)> EmptyValues = new (string From, string To)[0];

        public MapDef(string mappedType, List<(string From, string To)> values)
        {
            MappedType = mappedType;
            Values = values;
        }

        public override bool Equals(object? obj) => obj is MapDef def && Equals(def);

        public bool Equals(MapDef other)
        {
            // Deep equal
            return MappedType == other.MappedType &&
                   (Values ?? EmptyValues).SequenceEqual(other.Values ?? EmptyValues);
        }

        public override int GetHashCode()
        {
            // Deep hash
            int hashCode = 2119969645;
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(MappedType);
            foreach(var item in Values) {
                hashCode = hashCode * -1521134295 + EqualityComparer<(string From, string To)>.Default.GetHashCode(item);
            }
            return hashCode;
        }
    }
}

internal static class DiagnosticHelper
{
    public static DiagnosticDescriptor _descInvalidTypeOfMappedValue { get; } =
        new("EMG000", "invalid type of mapped value", "the value must be enum value, but found '{0}'", "EnumMapper", DiagnosticSeverity.Error, true);


    public static Diagnostic InvalidTypeOfMappedValue(Location? location, object? foundValue)
    {
        return Diagnostic.Create(_descInvalidTypeOfMappedValue, location, foundValue);
    }
}
