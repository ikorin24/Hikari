#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;

namespace Hikari.Generator;

[Generator(LanguageNames.CSharp)]
internal class BufferDataStructGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("BufferDataStructAttribute.g.cs", """
// <auto-generated>

#nullable enable

namespace Hikari
{
    [global::System.AttributeUsage(System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
    internal sealed class BufferDataStructAttribute : global::System.Attribute
    {
        public BufferDataStructAttribute() { }
    }
}
""");
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Hikari.BufferDataStructAttribute",
            static (_, ct) => true,
            static (context, ct) => context);

        var structLayoutAttr = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("System.Runtime.InteropServices.StructLayoutAttribute") ?? throw new Exception("StructLayoutAttribute is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        context.RegisterSourceOutput(source.Combine(structLayoutAttr), static (context, x) =>
        {
            var (source, structLayoutAttr) = x;
            var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
            var typeNode = (TypeDeclarationSyntax)source.TargetNode;

            if(typeNode.Modifiers.Any(SyntaxKind.PartialKeyword) == false) {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NotPartialStruct, typeNode.Identifier.GetLocation()));
                return;
            }
            if(typeSymbol.IsUnmanagedType == false) {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NotUnmanagedType, typeNode.Identifier.GetLocation()));
                return;
            }
            foreach(var attr in source.Attributes) {
                if(SymbolEqualityComparer.Default.Equals(attr.AttributeClass, structLayoutAttr)) {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.DuplicatedStructLayout, typeNode.Identifier.GetLocation()));
                    return;
                }
            }

            uint alignment = 1;
            uint size = 0;
            foreach(var field in typeSymbol.GetMembers().OfType<IFieldSymbol>()) {
                var fieldTypeInfo = GetTypeAlignmentAndSize(field.Type);
                alignment = Math.Max(alignment, fieldTypeInfo.Alignment);
                size += fieldTypeInfo.Size;
            }

            var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
                ? ""
                : $"namespace {typeSymbol.ContainingNamespace};";


            var code = $$"""
// <auto-generated>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

{{ns}}

[global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Sequential, Size = {{size}}, Pack = {{alignment}})]
partial struct {{typeSymbol.Name}}
{
}
""";

            var filename = typeSymbol
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("global::", "")
                .Replace("<", "_")
                .Replace(">", "_")
                + ".g.cs";
            context.AddSource(filename, code);
        });
    }

    private static (uint Alignment, uint Size) GetTypeAlignmentAndSize(ITypeSymbol type)
    {
        return type switch
        {
            _ => (1, 1),
        };
    }
}

#pragma warning disable RS2008
file static class DiagnosticDescriptors
{
    private const string Category = "Hikari.Generator";

    public static readonly DiagnosticDescriptor NotPartialStruct = new(
        id: "HKRG001",
        title: "Not partial struct",
        messageFormat: "The struct must be partial",
        category: Category,
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NotUnmanagedType = new(
        id: "HKRG002",
        title: "Not unmanaged type",
        messageFormat: "The struct must be unmanaged type",
        category: Category,
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor DuplicatedStructLayout = new(
        id: "HKRG003",
        title: "Duplicated StructLayout",
        messageFormat: "The struct already has StructLayout attribute",
        category: Category,
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);
}
#pragma warning restore RS2008
