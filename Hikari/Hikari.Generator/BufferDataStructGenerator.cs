#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Hikari.Generator;

[Generator(LanguageNames.CSharp)]
internal class BufferDataStructGenerator : IIncrementalGenerator
{
    private static readonly Regex _backingFieldRegex = new(@"^<(.+)>k__BackingField$", RegexOptions.Compiled);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("BufferDataStructAttribute.g.cs", """
// <auto-generated>

#nullable enable

namespace Hikari;

[global::System.Diagnostics.Conditional("COMPILE_TIME_ONLY")]
[global::System.AttributeUsage(System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
internal sealed class BufferDataStructAttribute : global::System.Attribute
{
    public BufferDataStructAttribute() { }
}

""");
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Hikari.BufferDataStructAttribute",
            static (_, ct) => true,
            static (context, ct) => context);

        var structLayoutAttr = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("System.Runtime.InteropServices.StructLayoutAttribute") ?? throw new Exception("StructLayoutAttribute is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        context.RegisterSourceOutput(source.Combine(structLayoutAttr), static (context, x) =>
        {
            var (source, structLayoutAttr) = x;
            var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
            var typeNode = (TypeDeclarationSyntax)source.TargetNode;

            if(typeNode.Modifiers.Any(SyntaxKind.PartialKeyword) == false) {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NotPartialStruct, typeNode.Identifier.GetLocation()));
                return;
            }
            foreach(var attr in source.Attributes) {
                if(SymbolEqualityComparer.Default.Equals(attr.AttributeClass, structLayoutAttr)) {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.DuplicatedStructLayout, typeNode.Identifier.GetLocation()));
                    return;
                }
            }
            if(typeSymbol.IsUnmanagedType == false) {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NotUnmanagedType, typeNode.Identifier.GetLocation()));
            }

            int currentOffset = 0;
            var fields = new List<(string Name, string Type, int Alignment, int Size, int Offset)>();

            var fieldDataList = new List<FieldData>();
            foreach(var field in typeSymbol.GetMembers().OfType<IFieldSymbol>()) {
                if(TryGetFieldData(field, out var fieldData) == false) {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.NotSupportedFieldType,
                            field.DeclaringSyntaxReferences[0].GetSyntax(context.CancellationToken).GetLocation(),
                            field.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                    continue;
                }
                fieldDataList.Add(fieldData);
            }

            var structAlignment = 1;
            foreach(var field in typeSymbol.GetMembers().OfType<IFieldSymbol>()) {
                if(TryGetFieldData(field, out var fieldData) == false) {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.NotSupportedFieldType,
                            field.DeclaringSyntaxReferences[0].GetSyntax(context.CancellationToken).GetLocation(),
                            field.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                    continue;
                }
                var o = RoundUp(fieldData.Alignment, currentOffset);
                fields.Add((
                    Name: fieldData.FieldName,
                    Type: fieldData.TypeName,
                    Alignment: fieldData.Alignment,
                    Size: fieldData.Size,
                    Offset: o));
                currentOffset = o + fieldData.Size;
                structAlignment = Math.Max(structAlignment, fieldData.Alignment);
            }
            var structSize = (currentOffset == 0) ? 1 : RoundUp(structAlignment, currentOffset);

            var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
                ? ""
                : $"namespace {typeSymbol.ContainingNamespace};";

            var (beginSource, endSource) = GetContainingType(typeSymbol);

            var offsets = fields.Select(x => $$"""
        /// <summary>
        /// <see cref="{{x.Type}}"/> = (alignment: {{x.Alignment}}, size: {{x.Size}})
        /// </summary>
        public const int {{x.Name}} = {{x.Offset}};
""");

            var code = $$"""
// <auto-generated>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

{{ns}}
{{beginSource}}

[global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Explicit, Size = {{structSize}})]
partial {{(typeSymbol.IsRecord ? "record struct" : "struct")}} {{typeSymbol.Name}}
{
    private static class OffsetOf
    {
{{string.Join("\n", offsets)}}
    }
}

{{endSource}}

""";

            var filename = typeSymbol
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("global::", "")
                .Replace("<", "_")
                .Replace(">", "_")
                + ".g.cs";
            context.AddSource(filename, code);
        });
    }

    private static (string BeginSource, string EndSource) GetContainingType(INamedTypeSymbol typeSymbol)
    {
        var current = typeSymbol;
        var begin = new StringBuilder();
        var end = new StringBuilder();
        while(true) {
            if(current.ContainingType is INamedTypeSymbol containingTypeSymbol == false) {
                break;
            }
            var typeKind = (containingTypeSymbol.TypeKind, containingTypeSymbol.IsRecord) switch
            {
                (TypeKind.Class, true) => "record",
                (TypeKind.Class, false) => "class",
                (TypeKind.Struct, true) => "record struct",
                (TypeKind.Struct, false) => "struct",
                (TypeKind.Interface, _) => "interface",
                _ => "_",
            };
            begin.AppendLine($$"""
partial {{typeKind}} {{containingTypeSymbol.Name}}
{
""");
            end.AppendLine("}");
            current = containingTypeSymbol;
        }
        return (begin.ToString(), end.ToString());
    }

    private static bool TryGetFieldData(IFieldSymbol field, out FieldData data)
    {
        // backing field to name
        // (ex)
        // <Foo>k__BackingField -> Foo
        var name = _backingFieldRegex.Replace(field.Name, "$1");
        var typeName = field.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        bool isSupported;
        (isSupported, data) = typeName switch
        {
            "int" or "uint" or "float" => (true, new FieldData(name, typeName, 4, 4)),
            "global::System.Half" => (true, new FieldData(name, typeName, 2, 2)),
            "global::Hikari.Vector2" or "global::Hikari.Vector2i" or "global::Hikari.Vector2u" => (true, new FieldData(name, typeName, 8, 8)),
            "global::Hikari.Vector3" or "global::Hikari.Vector3i" or "global::Hikari.Vector3u" => (true, new FieldData(name, typeName, 16, 12)),
            "global::Hikari.Vector4" or "global::Hikari.Vector4i" or "global::Hikari.Vector4u" or "global::Hikari.Color4" or "global::Hikari.RectF" => (true, new FieldData(name, typeName, 16, 16)),
            "global::Hikari.Matrix2" => (true, new FieldData(name, typeName, 8, 16)),
            "global::Hikari.Matrix3" => (true, new FieldData(name, typeName, 16, 48)),
            "global::Hikari.Matrix4" => (true, new FieldData(name, typeName, 16, 64)),
            _ => (false, new FieldData(name, typeName, 1, 1)),
        };
        return isSupported;
    }

    private static int RoundUp(int k, int n)
    {
        return (n + k - 1) / k * k;
    }

    private record struct FieldData(string FieldName, string TypeName, int Alignment, int Size);
}

#pragma warning disable RS2008
file static class DiagnosticDescriptors
{
    private const string Category = "Hikari.Generator";

    public static readonly DiagnosticDescriptor NotPartialStruct = new(
        id: "HKRG001",
        title: "Not partial struct",
        messageFormat: "The struct must be partial",
        category: Category,
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NotUnmanagedType = new(
        id: "HKRG002",
        title: "Not unmanaged type",
        messageFormat: "The struct must be unmanaged type",
        category: Category,
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor DuplicatedStructLayout = new(
        id: "HKRG003",
        title: "Duplicated StructLayout",
        messageFormat: "The struct already has StructLayout attribute",
        category: Category,
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NotSupportedFieldType = new(
        id: "HKRG004",
        title: "Not supported field type",
        messageFormat: "The type '{0}' is not supported for field type",
        category: Category,
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);
}
#pragma warning restore RS2008
